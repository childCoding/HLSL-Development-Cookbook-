# 简介

## 本章概括
* 半球形环境光
* 方向光
* 点光
* 斑点光
* **胶囊光**
* 投影纹理-点光
* 投影纹理-斑点光
* **多光源情况**

## 介绍

前向光照是一个非常一般的方法在计算不同光源和场景中其他元素相互作用时，例如网格和特效。前向光照方法已经存在从固定管线时期（当时可编程着色器还是一个梦想）直到实现可编程着色器的今天。

一个高级的观点，这个方法工作通过每绘制一个网格需要枚举一次场景中光源。每一个draw call光源通过添加颜色值来点亮最终显示在屏幕上的图片。性能方面，他是非常昂贵的-一个场景有N个光源和M个网格，我们将需要调用N×M次draw call。提高性能有不同的方法，下面的列包含了四大常用的优化：
* 使用所有完全不透明的网格来预热深度缓冲区。（这个方法不会浪费资源，不会在渲染像素时被离相机更近的像素重写）
* 渲染场景中相机时，跳过不可见的光源和场景元素。
* 做边界测试，计算哪个光源影响到哪个网格。基于这个结果，如果光源或网格不相交，跳过他们的draw call。
* 把影响到同一个网格的多个光源合并到单次draw call里，这个方法减少了draw call的次数和开销，但是需要预先准备网格的光照信息。

场景的深度渲染，上面提到的第一种方法，能非常简单的实现，只要要求shader输出深度值即可。第二和第三中方法的实现在CPU，所以我们就不在本书讨论。第四种方法的解释将在本章的最后。由于每一种方法偶是相互独立的，推荐一起使用以提高综合性能。

由于延迟光照和**平铺光照（烘焙？）** 性能方面的提升，前向光照最近这几年不再受欢迎（将在下一章介绍），但明白其如何工作仍然是非常重要的，有下面几个原因：
* 前向光照能完美的照亮场景里不完全透明的元素。实际上延迟光照方法只能拿到不透明的元素，这意味着前向光照方法仍然被需要包含半透明元素的场景中。
* 前向光照在低质量渲染时执行得更好，例如低分辨率反射图。
* 在原型设计和实时性能不重要的情况下，前向光照能更简单的照亮一个场景。

用于渲染的高级着色器语言覆盖了下面所有的秘诀，这意味着读者们将需要明白怎样去做下面几件事情：
* 编译和加载shaders
* 准备能加载和管理场景的一个系统
* 准备一个支持Direct3D draw call的shader渲染框架

使用这项技术的全部顶点缓冲必须包含位置和法线信息。为了达到平滑的结果，使用平滑的顶点法线（应该避免表面法线）。

注意，这个像素着色器必须为每一个网格提供一个像素值。每个网格的颜色值可能是一个常数或者采样来至一个纹理。

## 半球形环境光
环境光是最容易实现的光照模型，但是它对场景的整体外观感受非常的重要。更多的情况，环境光指的是场景中的任意光源，它不直接与特定的光源关联。这个定义是非常灵活的,它的实现一会将展示。

在过去，场景中每一个网格都使用一个常量的颜色值得到一个扁平的结果。随着可编程着色器变成可能，程序员从常量颜色值到把网格法线考虑进去从而避免扁平外观的解决方案。半球形光照是一个常规的做法在实现环境光方面，他把法线考虑进去从而不需要许多的计算，下面的截图显示了相同的网格通过常量环境颜色值（左边）和半球形环境光照（右边）渲染的对比。
![](https://raw.githubusercontent.com/childCoding/HLSL-Development-Cookbook-/master/image/1-1.jpg)
你能够看到，常量环境光隐藏了网格所有的细节，而半球形环境光提供了更多详细的结果。

### 准备工作
半球形环境光在渲染时需要两种颜色来表现来自每个网格上面和下面的光线。我们将使用一个常量缓冲区来把颜色值传给像素着色器。使用下面的值来填充D3D11_BUFFER_DESC对象：

![](https://raw.githubusercontent.com/childCoding/HLSL-Development-Cookbook-/master/image/1-2.png)

这个描述符字段应该重置为0.

创建一个实际的缓冲区，它保存一个ID3D11Buffer对象的指针，并通过D3D divece的CreateBuffer函数，它这个buffer descriptor做为他的第一个参数，第二个参数为NULL，第三个参数就是你的ID3D11Buffer指针。

### 怎么做
所有的光照计算都将在像素着色器中进行，本书假定你拥有基本的知识来创建和调用场景中每一个网格的draw call。一个顶点着色器必须把每一个网格的位置转换到投影空间和把法线转换到世界空间。

*如果你不熟悉3D图形学种的不同空间（坐标系），访问微软的MSDN你能找到所有的信息[http://msdn.microsoft.com/en-us/library/windows/desktop/bb206269%28v=vs.85%29.aspx](http://msdn.microsoft.com/en-us/library/windows/desktop/bb206269%28v=vs.85%29.aspx)*

作为参考，下面的顶点着色器代码可以用于处理这些计算：
```
cbuffer cbMeshTrans : register( b0 )
{
     float4x4  WorldViewProj  : packoffset( c0 );
     float4x4  World    : packoffset( c4 );
}
struct VS_INPUT
{
     float4 Pos  : POSITION;
     float3 Norm  : NORMAL;
     float2 UV  : TEXCOORD0;
};
struct VS_OUTPUT
{
     float4 Pos  : SV_POSITION;
     float2 UV  : TEXCOORD0;
     float3 Norm  : TEXCOORD1;
};
VS_OUTPUT RenderSceneVS(VS_INPUT IN)
{
    VS_OUTPUT Output;
    // Transform position from object to projection space
    Output.Pos = mul(IN.Pos, WorldViewProj);
    // Copy the texture coordinate through
    Output.UV = input.TextureUV;
    // Transform normal from object to world space
    Output.Norm = mul(IN.Norm, (float3x3)World);
    return Output;
}
```
***下载示例代码***
*您可以从您在http://www.packtpub.com上购买的所有书籍的示例代码，如果您在其他地方购买了这本书， 您可以访问http://www.packtpub.com/support 注册后直接通过邮件把文件发给您*

同样的，下面的代码也仅供参考，所有你可以随意的更改它来满足您的需求。

在像素着色器中，我们使用下面的声明来访问常量缓冲区中的值：
```
cbuffer HemiConstants : register( b0 )
{
     float3 AmbientDown   : packoffset( c0 );
     float3 AmbientRange  : packoffset( c1 );
}
```
除非你保持上面两个常量缓冲区中的值不变，否则你需要在场景渲染之前更新常量缓冲区。更新常量缓冲区需要使用到上下文函数，Map和Unmap。一旦常量缓冲区被更新，使用上下文函数PSSetConstantBuffers绑定到像素着色器。

我们的像素着色器将要使用下面的辅助函数来计算环境值，通过像素和法线。
```
float3 CalcAmbient(float3 normal, float3 color)
{
    // Convert from [-1, 1] to [0, 1]
    float up = normal.y * 0.5 + 0.5;
    // Calculate the ambient value
    float3 Ambient = AmbientDown + up * AmbientUp;
    // Apply the ambient value to the color
    return Ambient * color;
   }
```
这个函数假定normal的y元素来确定上下轴，如果你的坐标系统通过normal的不同元素来确定竖直轴，改变这个代码的坐标即可。

跟顶点着色器类似，像素着色器的代码入口依赖你指定的网格和需求。例如，下面的代码准备了输入和调用这个辅助函数。
```
    // Normalize the input normal
   float3 normal = normalize(IN.norm);
   // Convert the color to linear space
   color = float4(color.rgb * color.rgb, color.a);
   // Call the helper function and return the value
   return CalcAmbient(normal, color);
```
### 他怎样工作...
为了明白环境光怎样工作，搞清楚光在真实世界和计算机图形学中说如何工作是非常重要的，在实际生活中，光来源于不同的地方如灯泡或者太阳，有些光从光源发出经过直线达到我们的眼睛，但是更多的光会击中物体表面然后反射到不同的方向，根据物体的材质和颜色反射光的波长会有轻微的不同。我们把每一次光线的反射叫做反弹，由于光线反弹会改变它的波长，然后一些反弹后到波长会变得不可见。所以我们的眼睛看到通常是光源直射和经过很少次数反弹的光。下面的截图示范了一个光源发射了3条射线的情况，一条直接射入我们的眼睛，一条经过一次反弹到达我们的眼睛，一条经过两次反弹到达我们的眼睛。
![](https://raw.githubusercontent.com/childCoding/HLSL-Development-Cookbook-/master/image/1-3.png)

在计算机图形学中，光的计算仅限于实际到达观察者，通常指的是摄像机。计算相机的入射光通常简单到计算第一个反弹，主要是由于性能限制。